<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>UntitledAirQualityGame</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		html, body {
			width: 100%;
			height: 100%;
			background-color: #ffffff;
			overflow: hidden;
		}

		canvas {
			display: block;
			width: 100%;
			height: 100%;
			background: #fff;
		}
	</style>
</head>
<body>
	<canvas id="canvas"></canvas>
	
	<!-- BELOW IS WHERE PRETTY MUCH ALL THE CODE YOU WRITE IS GOING TO BE -->
	<script>
    
    
		// Get the canvas and context
		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');

		let canvasComb = 0;

		// Resize to fill the window
		function resize() {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
      canvasComb = (canvas.width > canvas.height) ? canvas.height : canvas.width;
		}

		window.addEventListener('resize', resize);
		resize();

		// Start coding the game below
    //total height
    canvas.height;
    canvas.width;
    let boardBorder = 2;
    let boardWidth = 6;
    let boardHeight = 6;
    let boardX = 10;
    let boardY = canvas.height/5;
    
    let cellBorder = 2;
    let cellWidth = (canvas.width*2)/(3*boardWidth);
    let cellHeight = (canvas.height*3)/(4*boardHeight);
   
    let mouseX = 0;
    let mouseY = 0;
    
    let pollution = 0;
    let player = [0, boardHeight-1];
    
    let menu = true;
    let options = false;
    let endLevel = false;
    let credits = false;
    
    let stage = 1;
    
  
    let particle = [[]];

    canvas.addEventListener("mousemove", e => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });

		// click detection
		canvas.addEventListener("click", () => {
      if(credits){
      	credits = false;
      }
      if(options){
        ///check first button
      	if(mouseX >= canvas.width*0.3 && mouseX <= canvas.width*0.7 ){
          
          if(mouseY >= canvas.height*0.4 && (mouseY <= canvas.height*0.45) ){
            //return
          	options = false;
            
            
          }
          if(mouseY >= canvas.height*0.5 && (mouseY <= canvas.height*0.55) ){
            //settings
            //currently non functional, because interally graphical/sounds which arent implemented
            options = false;
          	
          }
          if(mouseY >= canvas.height*0.6 && mouseY <= canvas.height*0.65){
            //credits
            credits = true;
          }
          if(menu == false && mouseY >= canvas.height*0.7 && mouseY <= canvas.height*0.75){
            //quit button
          	menu = true;
            options = false;
            endLevel = false;
          }
        }
       
      }else if(endLevel && menu == false){
        if(mouseX >= canvas.width*0.3 && mouseX <= canvas.width*0.7 ){
          if(mouseY >= canvas.height*0.5 && (mouseY <= canvas.height*0.55) ){
            //next level
            stage = stage+1;
          	endLevel = false;
        		startGame();
          }
          if(mouseY >= canvas.height*0.6 && mouseY <= canvas.height*0.65){
            //options button
          	options = true;
          }
          if(mouseY >= canvas.height*0.7 && mouseY <= canvas.height*0.75){
            //quit button
          	menu = true;
            endLevel = false;
          }
        }
        
          
        
      }else if(menu === false){//on the level
        	//checks for options
          if(mouseX >= canvas.width*0.95 && mouseX <= canvas.width*0.99 ){
            if(mouseY >= canvas.height*0.01 && (mouseY <= canvas.width * 0.05) ){
              options = true;
            }
          }
        
        	const col = Math.floor((mouseX - boardX) / cellWidth);
  				const row = Math.floor((mouseY - boardY) / cellHeight);
        	
          // Check if player is already at top-right corner and clicked that same cell
          if (player[0] === boardWidth - 1 && player[1] === 0 && col === player[0] && row === player[1]) {
            endLevel = true;             // skip normal move logic
          }

          if (col >= 0 && col < boardWidth &&
          row >= 0 && row < boardHeight) {
            if (((col == player[0] + 1 || col == player[0] - 1) && row == player[1]) || ((row == player[1] + 1 || row == player[1] - 1) && col == player[0])) {
              console.log("clicked cell", col, row, "value=", board[col][row]);
              //incremints polution and clears tiles
              if (board[col][row] > -1) {
              	pollution += board[col][row];
                for(let q = 0; q<board[col][row]; q++){
                  particle.push([
                    canvas.width*0.85,
                    canvas.height*0.85,
                    (Math.floor(Math.random() * 4) + 2)*(Math.floor(Math.random()*2)*2-1),
                    (Math.floor(Math.random() * 4) + 2)*(Math.floor(Math.random()*2)*2-1)
                  ]);
                }
                 + boardWidth
                board[col][row] = -1;
              }
              
              //moves the player to the square
              player[0] = col;
              player[1] = row;
            }
          }	
      } else if(menu){//if on the main menu
        if(mouseX >= canvas.width*0.3 && mouseX <= canvas.width*0.7 ){
          if(mouseY >= canvas.height*0.5 && (mouseY <= canvas.height*0.55) ){
            //start game button
            stage = 1;
          	menu = false;
            startGame();
          }
          if(mouseY >= canvas.height*0.6 && mouseY <= canvas.height*0.65){
            //options button
          	options = true;
          }
        }
      }
		});
		
    //Make a 2d arrayList that will be able to be modularly displaced on the screen. It should draw the number stored in it
    const board = [];
    for(let h = 0; h<boardWidth;h++){
      board.push([]); 
      for(let j = 0;j<boardHeight;j++){
    		board[h].push(0); 
      }
    }
    randomizeBoard();    
    

    
    //functions that are needed
    //this function should randomize the numbers in board
		function randomizeBoard() {
      particle = [[]];
    	for(let k = 0; k<board.length;k++){
       	for(let j = 0; j<board[k].length;j++){
        	if(board[k][j] != null){
          	board[k][j] = (Math.floor(Math.random()*3));
            
          }
        } 
      }
      board[0][board[0].length - 1] = -2;
      board[board.length - 1][0] = -3;
    }
    function startGame() {
      randomizeBoard();     // regenerate new numbers
      player = [0, boardHeight - 1]; // move to bottom-left
      pollution = 0;        // reset pollution
      return;   
    }
    function draw(){
      //clear the screen
      ctx.fillStyle = "white";
      ctx.fillRect(0,0,canvas.width,canvas.height);
      if(menu == true){//Starting Menu Drawing
        //buttons
        ctx.fillStyle = "gray";
       	ctx.fillRect(canvas.width*0.3, canvas.height*0.5, canvas.width*0.4, canvas.height*0.05);
        ctx.fillRect(canvas.width*0.3, canvas.height*0.6, canvas.width*0.4, canvas.height*0.05);
        //Text
        ctx.textAlign = 'center';
        ctx.fillStyle = "black";
        ctx.font = "600 30px Arial"; 
        ctx.fillText("Pollution Passenger", canvas.width*0.5, canvas.height*0.1);
        ctx.font = "10px Arial";
        ctx.fillText("Start",canvas.width*0.5, canvas.height*0.525);
        ctx.fillText("Options",canvas.width*0.5, canvas.height*0.625);
        ctx.textAlign = 'left';
        
      } else if(menu == false){//Game drawing
        //options button
        ctx.fillStyle = "gray";
        ctx.fillRect(canvas.width*0.95, canvas.height*0.01, canvas.width*0.04, canvas.width*0.04);
        //make a display loop of the things
        ctx.fillStyle = "gray";
        ctx.fillRect(boardX-boardBorder, boardY-boardBorder, boardWidth*cellWidth+boardBorder*2, boardHeight*cellHeight+boardBorder*2);
        ctx.fillStyle = "black";
        ctx.fillRect(boardX, boardY, boardWidth*cellWidth, boardHeight*cellHeight);
        ctx.textAlign = 'center';
        ctx.fillStyle = "green";
        ctx.fillText("Pollution : "+pollution,10,10);
        ctx.fillStyle = "black";
        ctx.fillText("Stage : "+stage,canvas.width*0.5,20);
        ctx.textAlign = 'left';
        
        //draw the air particles
        ctx.fillStyle = "black";
     		ctx.fillRect( canvas.width*0.8, canvas.height*0.8, canvas.width*0.1, canvas.height*0.1 );
        ctx.fillStyle = "orange";
        for (let i = 0; i < particle.length; i++) {
      		ctx.fillRect(particle[i][0], particle[i][1], 5, 5);
      	}

        for(let k = 0; k<board.length;k++){
          for(let j = 0; j<board[k].length;j++){
            ctx.fillStyle = "white";//this draws the interior, so skipped the border
            ctx.fillRect(boardX+k*cellWidth+cellBorder,//x start
                         boardY+j*cellHeight+cellBorder,//y start
                         cellWidth-cellBorder*2,//width
                         cellHeight-cellBorder*2);//height

            //Code to change the color
            switch (board[k][j]) {
              case -3:
                ctx.fillStyle = "blue";
                ctx.fillText("School", k*cellWidth+boardX+cellBorder+boardWidth/2 , j*cellHeight+boardY+cellBorder+cellHeight/2 );
                break;
              case -2:
                ctx.fillStyle = "blue";
                ctx.fillText("Home", k*cellWidth+boardX+cellBorder+boardWidth/2 , j*cellHeight+boardY+cellBorder+cellHeight/2 );
                break;
              case 0:
                ctx.fillStyle = "green";
                break;
              case 1:
                ctx.fillStyle = "orange";
                break;
              case 2:
                ctx.fillStyle = "red";
                break;
            }
					
            
            ctx.fillText( board[k][j]+"" , (k)*cellWidth+boardX+cellBorder+boardWidth/2 , j*cellHeight+boardY+cellBorder+cellHeight/2 );
            
            if(player[0] == k && player[1] == j ){
              ctx.fillStyle = "blue";
              ctx.beginPath();
              ctx.arc( k*cellWidth+boardX+cellBorder+boardWidth/2 +cellWidth/2, j*cellHeight+boardY+cellBorder+cellHeight/2, (cellWidth-cellBorder*2)/4, 2 * Math.PI, 0);
              ctx.fill();
            }

          } 
      	}
    	}
      if(endLevel){
      	ctx.fillStyle = "rgba(200,200,200,0.8)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "rgba(100,100,100,0.5)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "rgba(200,200,200,0.8)";
        ctx.fillRect(canvas.width*0.2 ,0,canvas.width*0.6,canvas.height);
        //buttons
        ctx.fillStyle = "gray";
       	ctx.fillRect(canvas.width*0.3, canvas.height*0.5, canvas.width*0.4, canvas.height*0.05);
        ctx.fillRect(canvas.width*0.3, canvas.height*0.6, canvas.width*0.4, canvas.height*0.05);
        if(!menu){
        	ctx.fillRect(canvas.width*0.3, canvas.height*0.7, canvas.width*0.4, canvas.height*0.05);
        }
        
        ctx.textAlign = 'center';
        ctx.fillStyle = "black";
        ctx.font = "600 30px Arial"; 
        ctx.fillText("You Won", canvas.width*0.5, canvas.height*0.1);
        ctx.fillText("Pollution:"+pollution, canvas.width*0.5, canvas.height*0.3);
        ctx.font = "10px Arial";
        ctx.fillText("Next Level",canvas.width*0.5, canvas.height*0.525);
        ctx.fillText("Options",canvas.width*0.5, canvas.height*0.625);
        if(!menu){
          ctx.fillText("Quit",canvas.width*0.5, canvas.height*0.725);
        }       
        ctx.textAlign = 'left';
      }
      if(options){
        
        ctx.fillStyle = "rgba(200,200,200,0.8)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "rgba(100,100,100,0.5)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "rgba(200,200,200,0.8)";
        ctx.fillRect(canvas.width*0.2 ,0,canvas.width*0.6,canvas.height);
        
        //buttons
        ctx.fillStyle = "gray";
        ctx.fillRect(canvas.width*0.3, canvas.height*0.4, canvas.width*0.4, canvas.height*0.05);
       	ctx.fillRect(canvas.width*0.3, canvas.height*0.5, canvas.width*0.4, canvas.height*0.05);
        ctx.fillRect(canvas.width*0.3, canvas.height*0.6, canvas.width*0.4, canvas.height*0.05);
        if(!menu){
        	ctx.fillRect(canvas.width*0.3, canvas.height*0.7, canvas.width*0.4, canvas.height*0.05);
        }
        
        ctx.textAlign = 'center';
        ctx.fillStyle = "black";
        ctx.font = "600 30px Arial"; 
        ctx.fillText("Options", canvas.width*0.5, canvas.height*0.1);
        ctx.font = "10px Arial";
        ctx.fillText("Return",canvas.width*0.5, canvas.height*0.425);
        ctx.fillText("Settings",canvas.width*0.5, canvas.height*0.525);
        ctx.fillText("Credits",canvas.width*0.5, canvas.height*0.625);
        if(!menu){
          ctx.fillText("Quit",canvas.width*0.5, canvas.height*0.725);
        }       
        ctx.textAlign = 'left';
      }
      if(credits){
        ctx.fillStyle = "rgba(200,200,200,0.8)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "rgba(100,100,100,0.5)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "rgba(200,200,200,0.8)";
        ctx.fillRect(canvas.width*0.2 ,0,canvas.width*0.6,canvas.height);
        
      	ctx.fillStyle = "black";
        ctx.textAlign = 'center';
        ctx.fillText("Pollution Passenger", canvas.width *0.5, canvas.height * 0.1);
        ctx.fillText("Developers", canvas.width *0.5, canvas.height * 0.2);
        ctx.fillText("Christopher Duncan", canvas.width *0.5, canvas.height * 0.3);
        ctx.fillText("Darius", canvas.width *0.5, canvas.height * 0.4);
        ctx.fillText("Game made for teaching clean air principles", canvas.width *0.5, canvas.height * 0.5);
      }      
    }
    
    function particleUpdate() {
    	for (let i = 0; i < particle.length; i++) {
      	particle[i][0] += particle[i][2];
        particle[i][1] += particle[i][3];
        //change the modifiers to fix the size
        if (particle[i][0] > canvas.width*0.9 || particle[i][0] < canvas.width*0.8) particle[i][2] *= -1;
        if (particle[i][1] > canvas.height*0.9 || particle[i][1] < canvas.height*0.8) particle[i][3] *= -1;
      }
    }
    
    function gameLoop() {
      draw(); // draw everything
      particleUpdate();
      requestAnimationFrame(gameLoop); // schedule next frame
    }

    // Start the loop
    gameLoop();

		
		
		
		
		
	</script>
</body>
</html>
